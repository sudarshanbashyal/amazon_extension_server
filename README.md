# Project Overview
The aim of this project was to create a simple chrome extension to extract products from amazon. The general requirements provided are listed below: 

 - The extension should automatically detect when user lands on amazon product page when enabled.
 - The product title, images, description, prices, and rating should be extracted and saved. 
 - Allow users to make any changes to the extracted data before saving.
 - Allow users to view the saved data. 

**This is the server side repository. You can also find the client (chrome extension) repository along with setup and other related documentation for this project [here](https://github.com/sudarshanbashyal/amazon_extension_client)** 

# Installation Guidelines
## Prerequisites for installing the server side application:

 - [NodeJS](https://nodejs.org/en/download/package-manager) (Version used for project - 20.11.1)
 - [NPM](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) (Version used for project - 10.2.4)
 - [MongoDB](https://www.mongodb.com/) (Version used for project - 6.0.1)
 - [Redis](https://redis.io/) (Version used for project - 7,4,1 | via Docker)

## Installation Steps

 - Clone the repository using `git@github.com:sudarshanbashyal/amazon_extension_server.git`
 - Navigate into the directory where the project was cloned.
 - Install all the dependencies using `npm i`
 - Copy the `.env.sample` file into `.env` file, and add the necessary environment variables.
 - Ensure your MongoDB and Redis database services are up and running.
 - Run the server using `npm run dev`

# Architecture Details
## Technologies Used


 - [ExpressJS](https://expressjs.com/) - Minimal backend library on top of NodeJS.
 - [MongoDB](https://www.mongodb.com/) - MongoDB is used as the primary database for this project because of it's support for unstructured data compared to relational databases.
 - [Redis](https://redis.io/) - Used for caching query results, and for rate limiting. 
 -  [JWT](https://jwt.io/) - Primary means of authentication and authorization used in this application.
 -  [TypeScript](https://www.typescriptlang.org/) - Added for better type safety, and error handling. 
 - [GraphQL](https://graphql.org/) - API Query language used for all queries. 

## Mongo Database Schema
This project relies on just two database collections: users and projects:

 - Users Collection
	 
|Field|Description|Type|
|--|--|--|
| _id | Auto-generated ObjectID used as Primary Key  |Object ID
|name|Stores user's name|String
|email|Stores user's email|String
|password_hash|Stores user's password hash generated by encrypting plain text password|String

 - Products Collection
	 
|Field|Description|Type|
|--|--|--|
| _id | Auto-generated ObjectID used as Primary Key  |Object ID
|product_title|Stores the product title|String
|product_description|Stores the product description|String
|product_prices|Stores the product price. String field has been used in this case as storing not just the price as number, but also the currency would be ideal.|String
|product_image_urls|Stores the product image links|Array\<String>
|product_rating|Stores the product rating|Number
|product_url|Amazon page URL that the product comes from|String
|user|Reference to the Users Collection|Ref\<User>

## Performance, and Security Considerations
In order to make this application more performant, optimized, and secure, the following steps were taken into place:

 - **Password Hashing**<br/>
	Instead of storing the password as plain text, the password has been encrypted with multiple salting rounds to create a secure hash so that even in case of a data breach, sensitive information are not visible.
	
 - **Authentication and Authorization**<br/>
	 Proper auth has been implemented using JWT to make it so that users have to be logged in to save products. Authorization has been implemented on queries related to fetching products ensuring that users can only see the products saved by themselves.
	 
 - **Indexing**<br/>
	The `email` field from the User collection, and the `product_url` and `user` reference field from the Product collection has been indexed (along with the primary key) to ensure a fast lookup time.
	
 - **Pagination**<br/>
	 Pagination has been implemented in the query that retrieves saved products. This reduces the load on our database since only a small number of data need to be read at a time.
	 
  - **Caching with Redis**<br/>
	 To further reduce the load on our primary database, redis has been used to cache user specific data for product retrievals. Each time the user reads from from a particular page, a unique key is generated using the user id, the page number, and the page limit so that data from cache can be used if present.
	 The cache is invalidated each time the user saves a new product, so that their is no lag when retrieving a new product.
	 
 - **Rate limiting**<br/>
	 On top of caching, redis has also been utilized for rate limiting. This make the application vastly more secure, since DDoS is one of the most common server-side attacks. Rate limiting prevents this issue by setting a limit for how many times a server can be called by a given IP address.

## Future Improvements
To improve the application even further, the following quick improvements could be made:

- **Auto generated schemas**<br/>
	Currently, the GraphQL queries and mutations are set up as pure strings values on the frontend. However, auto generating the schemas from backend can result in better type-definitions, and fault tolerance on the frontend application, since even if small changes are made to the backend schema, the client will be able to detect it during build time.

- **Multi Token Authentication**<br/>
	Instead of relying on a single access token, using two different tokens: a refresh token and an access token can boost the security of the application by a long run, since both tokens will be needed to access any of the user's data.
	
- **Invalidating JWT Tokens**<br/>
	Each time a user logs out, their past tokens could be invalidated to ensure that no one else can use those tokens. This can be done in multiple ways:
	 - Store all the invalid tokens in a separate table, and reference this table for each request. This can be an easy implementation for token invalidation, but can consume a lot of database storage since tokens will have to be stored after each session.
	 - Maintain a token version for each user, and add the token version to the JWT payload. Each time a user logs out, increase the version for that user, so that all the expired tokens can be detected with just one field. 

	
